[{"id":0,"href":"/repopres/zh/docs/","title":"GitHub 仓库保存网民指南","section":"Netizen's Guide to Preserving Github Repositories","content":"GitHub 仓库保存网民指南# 欢迎使用本指南，请通过左侧目录浏览内容。\n"},{"id":1,"href":"/repopres/zh/docs/posts/introduction/","title":"Introduction","section":"Posts 指南章节","content":"介绍：\n本指南是一个用于保存 GitHub 仓库的决策向导，重点关注如何评估、准备并保存托管在 github.com 上的源代码。\n为什么要保存源代码？\n软件已经成为现代社会基础设施的一部分，它不仅是工具，也承载着文化、科学研究和社会实践等丰富信息。 如果今天的源代码无法被保存下来，未来的研究者将很难理解我们这一代的技术与社会运作方式。 因此，越来越多的档案机构开始把软件视为数字档案体系中的 “first-class citizen（第一等公民）”。\n软件为什么处在风险之中\n内在的易失性 软件依赖特定的执行环境，例如操作系统版本、依赖库、硬件架构和编译器。一旦这些环境不再被支持，软件就难以运行或重现。不同的版本控制系统（Git、Subversion 等）也各有自己的数据模型，目前并没有统一的长期保存格式。 项目被放弃 很多 GitHub 仓库是个人或小团队维护的，一旦维护者离开、兴趣转移或组织解散，代码就可能无人管理，随时面临被删除或 “消失” 的风险。 DMCA 与版权 GitHub 会根据 DMCA 通知下架仓库；版权纠纷或授权不清，也可能导致代码被迫移除。 审查与下架 在某些情况下，出于政策、公司策略或法律原因，仓库可能被平台隐藏或彻底删除。 一个 GitHub 仓库都包含什么\n一个仓库并不仅仅是源代码，它由多种组件构成：\n主要内容——“快照”部分 Source code（源代码） Commit history（提交历史） Branches（分支） Tags（标签） README 文件 License（许可证） 次要/周边内容——更接近“情境化保存” Issues：问题跟踪和讨论 Pull requests：合并请求和代码审查记录 Releases：正式发布版本及其附带文件 Actions workflows：GitHub Actions 自动化工作流 Projects / Wiki 等项目文档 Discussions：社区讨论区，用于更开放的协作交流 这些组成部分中，有些更适合被完整采集（例如源代码与提交历史），有些则只能以截图、导出或说明性文档的方式被“间接”保存。\n元数据与相关资料的问题\n元数据和相关资料（文档、截图、研究论文、用户手册等）对软件保存非常关键。 它们不仅帮助理解这份代码“做什么”，还说明了它在什么情境下被使用、谁参与了开发、有哪些依赖关系。这些差异会显著影响你选择哪一种保存路径与工具。\n总结：软件为什么难以归档？我们现在处在什么状态？\n软件面临的风险：内在易失性、项目被放弃、DMCA/版权、审查 关键问题包括： 为什么归档源代码这么困难？ 当前的软件保存生态是什么状况？ “最夸张”的例子：GitHub Arctic Code Vault（北极冷库） “最开放、覆盖面最广”的例子：Software Heritage 一个 GitHub 仓库的哪些组成部分值得保存？ 主要内容：源代码、提交历史、分支、标签、README、许可证等 次要内容：issue、pull request、release、actions workflow、discussions 等 "},{"id":2,"href":"/repopres/zh/docs/posts/%E7%AC%AC%E4%B8%80%E6%AD%A5%E8%AF%84%E4%BC%B0/","title":"First steps: Evaluating","section":"Posts 指南章节","content":"第一步：评估\n在真正开始归档之前，先问自己几个根本性的问题： 你为什么要保存这个仓库？它对谁重要？它在更大的软件生态里处于什么位置？\n你为什么要归档这个仓库？\n弄清动机有助于选择合适的保存策略：\n软件史保存： 为软件发展史贡献一份证据。 个人备份： 确保自己的作品安全、有地方可以找回。 社群保存： 为某个特定社区保存重要的软件资源。 在评估时，你可以考虑：\n你的目标更偏向哪一种？ 是软件历史？ 还是个人备份？ 这个软件是不是已经被保存到其他地方？ 可以先去查一查：Software Heritage 是否已经有这份代码。 GitHub Repository Evaluation Checklist（GitHub 仓库评估清单）： 软件是否相对完整、可用？ 是否还存在尚未解决的重大问题？ 是否依赖其他外部组件（例如外部服务、专有库）——这些东西只靠源代码无法覆盖？ 代码目前托管在哪些平台？ 从常见的开发平台到小众档案库，都要尽量列出。 归档时，能否尽量贴合原本的托管环境？ 例如镜像原始目录结构、保留原始仓库 URL 等。 能否抓取到版本控制系统中完整的开发历史？ 包括各种 VCS：Git、Mercurial、Subversion、Darcs、Bazaar、CVS 等。 对于一些更系统化的软件保存实践，你还可能会遇到专门的元数据表，例如一个 version_history.csv 可能包含：\ndirector name（项目负责人姓名） author name / email（作者姓名与邮箱） date original（最初发布日期） curator name / email（整理者姓名与邮箱） release tag（版本标签） commit message（提交说明） 可能涉及的任务包括：\n誊写手写的旧代码； 从不同硬件上找回散落的代码副本； 访谈开发者、维护者或使用者，补充背景信息。 这些步骤可以帮助你判断： 这个仓库值得投入多少保存工作，以及最适合把它送往哪一种保存路径。\n"},{"id":3,"href":"/repopres/zh/docs/posts/%E5%86%B3%E7%AD%96%E6%8C%87%E5%8D%97%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E4%B8%8E%E7%9B%AE%E7%9A%84%E5%9C%B0/","title":"Decision Guide","section":"Posts 指南章节","content":"决策指南：保存资源与目的地\n根据你的身份、可用资源和技术能力，你可以选择不同的路径来保存软件仓库：\n完全由自己在本地保存； 把源代码交给像 Software Heritage 这样的公共软件档案库； 或者与某个机构的数字保存系统合作。 每一种方案都有优点与局限，你可以根据下面的特点作出选择。\n本地保存路线# Pros 优点：\n只需要依赖你自己，不需要等待外部机构审批。 你可以自己制定保存策略： 例如文件夹结构、想要保存哪些相关材料（文档、截图、论文等）、需要记录哪些说明信息。 隐私控制完全在你手里： 你可以决定谁能访问这些软件、副本存放在哪里。 Cons 缺点：\n…（此处原文用省略号表示，具体劣势可根据你的实际情况补充） Software Heritage Route（Software Heritage 路线）# Pros 优点：\n有机构背书的长期项目，并且有稳定的资金与持续运营。 归档流程严谨、集中管理，适合长期保存。 你的软件会与其他项目放在一起，被放入更大的历史语境中——这对软件史研究非常有价值。 Cons 缺点：\n受欧洲版权法（European copyright law）约束。 元数据字段由 Software Heritage 定义，用户无法随意更改。 归档决策需要经过审核，某些请求可能不会被接受。 Institutional Route（机构路线）# Pros 优点：\n机构层面的资源与稳定性（经费、硬件、长期规划等）。 可以与数字保存人员（digital preservationists）及其他同事合作，为软件提供更完整的文献与上下文。 Cons 缺点：\n需要使用你所在机构已经部署的 DAMS（Digital Asset Management System）， 而这些系统未必是专门为软件归档设计的，有时会不太适配源代码和版本控制的特性。 "},{"id":4,"href":"/repopres/zh/docs/posts/local-solution/","title":"Local Solution","section":"Posts 指南章节","content":"本地方案：\n可以链接到现有的工具（例如 MackinationsAI），或自己制作一个脚本工具， 其中包含 PowerShell / Bash 等命令，帮助你半自动地完成备份与整理。 参考 NDSA Standards（NDSA《数字保存等级》（Levels of Digital Preservation））： （链接：NDSA levels of digital preservation） Tasks for Level 1（一级任务） Tasks for Level 2（二级任务） Tasks for Level 3（三级任务） Tasks for Level 4（四级任务） 通过这些等级，你可以把本地方案分解成一个个可执行的小步骤，从“可恢复的备份”逐步提升到“真正面向长期保存的多副本体系”。\n"},{"id":5,"href":"/repopres/zh/docs/posts/software-heritage/","title":"Software Heritage","section":"Posts 指南章节","content":"关于软件遗产# Software Heritage 成立于 2016 年，由 Inria 发起，并与 UNESCO 合作。 它的使命是：“收集、保存，并让所有曾经写过的软件源代码可以被方便访问”。 他们主要从各种平台收集源代码，其中最重要的来源之一就是 GitHub。\n你可以先访问他们的在线档案： https://archive.softwareheritage.org/ 如果你的仓库还不在其中，可以通过保存请求页面发起 “origin save request”： https://archive.softwareheritage.org/save/\nSoftware Heritage 采集流程# 在 2021 年的研究论文中，Software Heritage 提出了 Software Heritage Acquisition Process（SWHAP） 的概念，用来描述他们如何系统性地收集和整理软件源代码。这套流程的目标是：\n覆盖尽可能多的软件托管平台； 保存完整的开发历史，而不仅仅是一份最新快照； 记录清楚来源、作者和后期整理者等“谱系信息”。 Phases（阶段）# （原文此处使用省略号，详细阶段可根据 SWHAP 论文补充）\n在具体的工作流程中，元数据表里通常会记录：\ndirector name（项目负责人） author name / email（作者姓名与邮箱） date original（最初发布日期） curator name / email（整理者姓名与邮箱） release tag（版本标签） commit message（整理团队写下的简短说明） 值得注意的是，现代版本控制系统（VCS）往往有两套不同的元数据：\n一套来自原始作者与开发团队（谁写了代码、何时提交）； 另一套来自后期的整理者或机构（谁抓取、谁审核、谁导入到档案系统）。 这种区分可以帮助研究者理解： 哪些信息来自原始开发活动，哪些则是归档过程本身留下的“第二层历史”。\nExplain Merkle Directed Acyclic Graph (DAG)（Merkle 有向无环图）# Software Heritage 的整个数据集合本质上是一个巨大的 Merkle DAG。 在这套结构中：\n每一个对象（文件、目录、提交）都通过散列值（hash）唯一标识； 对象之间的关系（例如一个目录包含哪些文件、一次提交指向哪些父提交）构成一个 有向无环图（Directed Acyclic Graph）； 这样的结构可以： 避免重复存储相同内容（去重）； 追踪版本之间的演化关系和重用关系； 为每个节点建立清晰的 provenance（来源）链条。 How often Software Heritage scans for new code（Software Heritage 多久抓取一次新代码）# Software Heritage 使用一种 adaptive scheduling discipline（自适应调度策略） 来决定何时重新抓取某个代码托管点：\n对更新频繁、活动活跃的仓库，会更频繁地扫描； 随时间观察到变化越来越少时，会逐步降低扫描频率； 这样既能保证新版本被及时收集，又不会浪费过多抓取和存储资源。 Where they keep their data（他们的数据存放在哪里）# （原文提示 “discuss mirrors etc”，即需要根据 Software Heritage 的镜像与备份策略进行补充说明。） 总体来说，Software Heritage 通过多个镜像站点和合作机构分布式保存数据，以降低单点故障和地域性风险。\n"},{"id":6,"href":"/repopres/zh/docs/posts/institution/","title":"Institution","section":"Posts 指南章节","content":"机构\nSummarize Jonathan’s strategies, and other interviewees （此处原文是写作提示：需要综合 Jonathan 以及其他受访者在与机构 / DAMS 合作时的策略。 在中文版本中，你可以根据访谈内容补充具体做法、技巧和经验。） "},{"id":7,"href":"/repopres/zh/docs/posts/p2p-software-sharing-communities/","title":"P2P Software-Sharing Communities","section":"Posts 指南章节","content":"P2P软件分享社群\n如果你认为自己要保存的软件不太适合放进像 Software Heritage 这样的公共档案库， 或者希望在自己的硬盘之外，有更多人一起分担保存责任，那么把它种子化， 分发到 P2P 文件分享社群 可能是一条出路。 本工具包并不打算详细介绍这些社群的运作方式，这是本项目的“超出范围”部分。 如果你对此感兴趣，可以长期关注相关社区的 subreddit、Discord 等渠道， 等待加入邀请或公开征集信息（例如 “[this]” 或 “[that]” 这样具体的社群链接）。 "},{"id":8,"href":"/repopres/zh/docs/posts/how-to-get-more-involved/","title":"How to get more involved","section":"Posts 指南章节","content":"如何进一步参与？\nCiting SWH article: In the software preservation … （原文在此只留下了提示：可以引用 Software Heritage 的文章， 讨论在软件保存领域如何持续参与、做出贡献。 你可以在中文版本中补充：例如参与开源项目、向 Software Heritage 提交 save 请求、 在机构内推动软件保存政策等。） "},{"id":9,"href":"/repopres/zh/docs/about/repopres/","title":"Repopres","section":"About 关于本项目","content":"repopres# Netizen\u0026rsquo;s Guide to Preserving Github Repositories\n（《GitHub 仓库保存网民指南》）\n"},{"id":10,"href":"/repopres/zh/docs/contributions/contributions/","title":"Contributions","section":"Contributions 贡献","content":"Contributions 贡献# Interviewer 采访者# Jonathan M Farbowitz Emma Dickson Mark Hellar Redactor 编辑与撰写# Ven Koel Haoran "}]