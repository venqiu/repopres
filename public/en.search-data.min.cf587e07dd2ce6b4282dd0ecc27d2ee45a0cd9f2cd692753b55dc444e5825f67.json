[{"id":0,"href":"/repopres/en/docs/posts/introduction/","title":"Introduction","section":"Posts","content":"Introduction:\nThis is a decision guide for preserving a github repository. There are many approaches to doing this, with varying degrees of effort, difficulty, longevity, and dependability. The following guide outlines three main methods for preserving source code found on github.com.\nWhy is it important to preserve source code?\nSoftware has become an integral part of modern society, embodying significant portions of our cultural knowledge. However, as Di Cosmo and Zacchiroli eloquently state, unlike other forms of digital preservation, source code has not yet achieved the status of “first class citizen in the digital archive landscape.”\nWhy software is at risk:\nInherent obsolescence - Software depends on specific execution environments, languages, and dependencies that keep evolving and there is no unifying data model for version control systems.\nProject abandonment - Without active maintenance, the knowledge of specific softwares can be lost permanently.\nCensorship - Despite software frequently migrating between platforms, there is always a chance that code hosting platforms would remove content due to policy violations and political pressure.\nPlatform dependence - Most code hosting platforms do not offer any long term preservation guarantees. The 2015-16 shutdown of Gitorious and Google Code demonstrated this as over 1.5 millions projects had to relocate in a short timeframe.\nCurrent state of software preservation\nTwo major initiatives currently represent different approaches to software preservation. GitHub’s Arctic Code Vault takes a focused approach to creating a long-term physical backup. The initiative stores snapshots of public repositories in a decommissioned coal mine in the Svalbard archipelago, a location chosen for its geological stability. However, the Vault primarily focuses on creating snapshots rather than capturing complete development histories with all their evolution, functioning essentially more as a disaster recovery backup than an active archive.\nSoftware Heritage takes a fundamentally different approach to focus on broad accessibility and long-term viability. Rather than relying on a single backup location, Software Heritage maintains a geographic network of “mirrors” and operates on a principle of no a priori selection to archive comprehensively. As of June 2022, Software Heritage has archived over 180 million software origins with more than 12 billion unique source code files, making it the largest corpus of source code available on the planet.\nComponents of GitHub Repository\nUnderstanding what comprises a complete GItHub repository reveals the challenges in considering which elements are essential versus secondary.\nCore technical artifacts:\nSource code: The primary artifact Commit history: Record of changes that affect the file Branch: Separate workspace for new changes without affecting the main branch Tag: Marker referencing a specific commit within project history README: Overview documentation of the project License: Legal declaration governing use and distribution Recording these elements provides what might be called a comprehensive snapshot of the repository at a given point in time. This represents the minimum viable preservation effort as it captures the project with sufficient detail that future users could understand and potentially build upon the work. For software that never had significant community engagement, this level of preservation may be adequate.\nHowever, contemporary software development is an increasingly collaborative process. Preserving these secondary content provides a richer understanding of the repository as a community artifact, such as revealing the decision-making processes through which communities debate technical approaches, though the dynamic nature of these elements presents challenges for preservation.\nIssue and pull request: Bug reports and proposed code changes Wiki page: Extended, long-form information Project: Tool for planning and tracking work on GitHub Release: Software iteration for distribution including notes Actions: Platform allowing automated processes for continuous integration / continuous delivery Discussions: Collaborative communication forum The question of metadata and related materials\n[Added by ven] The question of metadata and related materials is a key one in archiving and software preservation. Different approaches to keeping and labeling the ancillary materials related to a piece of source code greatly shape the differences between preservation approaches.\nWhy software is at risk: inherent obsolescence, project abandonment, DMCA/copyright, censorship\nWhy is it hard to archive source code? What is the current state of software preservation The most extra: Github’s Arctic Vault The most open and encompassing: Software Heritage Components of Github Repository (easier said than done, conflicting information) Main content (recording this would just be a snapshot): source code, commit history, branches, tags, read.me, license Secondary content (recording this would be more like preserving a github repository): issues and pull requests, wiki pages, project boards, releases (?? isn’t this important), actions workflows, discussions "},{"id":1,"href":"/repopres/en/docs/","title":"Netizen's Guide to Preserving Github Repositories","section":"Netizen's Guide to Preserving Github Repositories","content":"Netizen\u0026rsquo;s Guide to Preserving Github Repositories# Welcome! Use the navigation on the left to browse the guide.\n"},{"id":2,"href":"/repopres/en/docs/posts/first-step/","title":"First steps: Evaluating","section":"Posts","content":"First steps: Evaluating\nBefore beginning the archival process, ask yourself fundamental questions about your goals and the repository’s significance.\nWhy Are You Archiving This Repository?\nUnderstanding your motivation helps determine the appropriate preservation approach:\nSoftware history preservation: Contributing to the history of software development\nPersonal backup: Ensuring your own work is safely stored\nCommunity preservation: Protecting software important to a specific community\nEmergency rescue: Saving at-risk code before it disappears\nResearch purposes: Preserving software for academic story or reproducibility\nAsk yourself, why are you archiving a github repository?\nHow to evaluate if a repository is worth preserving It’s significant in software history, technological development, or a specific community that you’re a part of It’s in danger of being removed, outlawed, or otherwise made inaccessible Software history or personal backup? Is it preserved already?\nCheck: Software Heritage Github Repository Evaluation Checklist\nHow complete and usable is the software? Are there fundamental issues that still have yet to be solved? Are there other dependencies that would not get covered by the source code? (idk) identify the code hosting places, from well known development platforms to niche archives try to accommodate specifics of source code’s hosting environment crawl development histories as captured by wide variety of version control systems (Git, Mercurial, Subversion, Darcs, Bazaar, CVS, \u0026amp; more) version_history.csv contains: director name, author name, author email, date original, curator name, curator email, release tag, commit message Tasks could involve: transcribing hand-written code, finding code from different hardware, interviews "},{"id":3,"href":"/repopres/en/docs/posts/decision-guide/","title":"Decision Guide","section":"Posts","content":"Decision Guide: Preservation Resources and Destinations:\nDepending on who you are and the skills you have, you may decide to preserve source code locally, through an organization like Software Heritage, or through your institution’s digital preservation system. There are pros and cons to each of these options:\nLocal route\nPros: You only need to rely on yourself You can make your own preservation decisions decide your own best practices (e.g. the types of metadata, ancillary materials, and other information to provide about each repo) Privacy: you have full control over the access of this software Cons: You are not bound to terms and services of any organization, or online platform, or copyright law You have to pay for your own storage space Software Heritage\nPros: Institutionally backed, sustained project with funding Rigorous archiving, centralized Contextualized with other softwares (good for software history) Cons: Subject to European copyright law Cannot change the metadata fields All decisions are subject to approval Institutional Route\nPros: Institutional resources and stability Digital preservationists and colleagues Cons: Need to work with the DAMS used by your institution already, which may not be suitable for archiving software "},{"id":4,"href":"/repopres/en/docs/posts/local-solution/","title":"Local Solution","section":"Posts","content":"Local Solution:\nLink to that MackinationsAI or make our own that has powershell commands and bash commands NDSA Standards (link to NDSA levels of digital preservation table) Tasks for Level 1 Tasks for Level 2 Tasks for Level 3 Tasks for Level 4 "},{"id":5,"href":"/repopres/en/docs/posts/software-heritage/","title":"Software Heritage","section":"Posts","content":"Software Heritage:\nAbout Software Heritage\nSoftware Heritage was founded in 2016, launched by Inria in partnership with UNESCO. Their mission is to “collect, preserve, and make readily accessible all the software source code ever written” (Source).Check if your repository is already by visiting their online archive at https://archive.softwareheritage.org/. If not, then issue an origin save request here.\nThe Software Heritage Acquisition Process\nIn their 2021 research paper, they outlined what they call the “Software Heritage Acquisition Process” (SWHAP). This process was developed to preserve source code from various sources, including but not limited to software development platforms like Github and Gitlab, legacy platforms like Google Code and Gitorious, package manager repositories like CPAn and npm, and FOSS (free and open source software) distributions such as Fedora and FreeBSD. The following contains a general overview of SWHAP so you can evaluate if Software Heritage is the right place for the code you’d like to preserve. You can find more information from their published research articles\nPhases\nCollect: Find the source code and related materials (e.g. research articles, pictures, drawings, user manuals) and gather it ‘as is’ Curate: Analyze and clean up the structure of raw materials (source code). This includes clarifying the production dates, contributors, and general history and evolution of the software. This information is logged as metadata, using vocabulary from CodeMet (e.g. software runtime platform, programming languages, authors, license) Archive: Upload or contribute the each category of materials to the appropriate infrastructures: Software Heritage for source code, Wikimedia for images and videos, open access repositories for research articles, Wikidata for software descriptions and properties, and so on Present: Create presentations, exhibitions, events, or websites from the results Software artifacts: How SWHAP divides their components\nThe following categories are how Software Heritage distinguishes the different components that make up the “raw materials” of software:\nfile contents (AKA ‘blobs’): the raw content of the source code in the form of bytes directories: a list of named directories, each pointing to other artifacts revisions (AKA ‘commits’): each recorded copy of the root directory is known as a revision releases (AKA tags): milestone revisions origins (software provenance): fine grained references to where source code artifacts have been retrieved from. projects: abstract entities that relate together several development resources, including websites, issue trackers, mailing lists, as well as software origins snapshots: records all entry points found there and where they pointed to. This would include branches for VCS, and suites for package distributions visits: link together software origins with snapshots. This is essentially a time stamp of when Software Heritage recorded a snapshot Metadata: version_history.csv ** **For each piece of software, the SWHAP recommends that preservationists collect relevant metadata file for each version of the software, in the form of a spreadsheet titled version_history.csv. Here is an example of one. These typically contain:\ndirector name: name of directory containing the source code of this version author name: name of the main author date original: original date when this version was made curator name: name of the curator person or team curator email: reference email of the acquisition process release tag: tag name if the directory contains a release, empty otherwise commit message: text containing a brief note from the curator team It is worth noting that modern VCS allow two sets of metadata: one for the author and one for the committer. This allows for the distinguishing between the original author of a software, and the person archiving it.\nExplain Merkle Direct Acyclic Graph (DAG) as their way of preventing unnecessary redundancies\nSoftware Heritages’ collection is in essence a big Merkle Direct Acyclic Graph (DAG), a multi-node structure in which each of the aforementioned software artifacts (file contents, directories, revisions) constitute one node. With each node having its own intrinsic cryptographic hash, Software Heritage is able to to avoid unnecessary duplication of code, contextualize source with the entire development of all source code in the collection, and establish provenance and code reuse.\nHow often Software Heritage scans for new code\nSoftware Heritage uses an adaptive scheduling discipline, specifically an “exponential backoff strategy.” This means that they run periodic checks of the source code they collect to scan for changes and edits. If the scan shows changes for any given software origin, they increase the frequency that that site is visited in the future. If the check does not show changes for the software, they decrease the scanning frequency.\nWhere they keep their data\n[discuss mirrors etc)\n"},{"id":6,"href":"/repopres/en/docs/posts/institution/","title":"Institution","section":"Posts","content":"Institution\nSummarize Jonathan’s strategies, and other interviewees "},{"id":7,"href":"/repopres/en/docs/posts/p2p-software-sharing-communities/","title":"P2P Software-Sharing Communities","section":"Posts","content":"P2P Software-Sharing Communities\nIf you believe the software you are attempting to preserve may not be welcome in on SWH, and you hope for more distribution and shared responsibility for preserving it beyond your own hard drive(s), then seeding it in P2P file-sharing communities may be the answer This is out of scope for this toolkit but if you are interested in joining then keep your eyes peeled on the subreddits and discords of communities such as [this] or [that] for opportunities to be invited into the community "},{"id":8,"href":"/repopres/en/docs/posts/how-to-get-more-involved/","title":"How to get more involved","section":"Posts","content":"How to get more involved?\nCiting SWH article: In the software preservation "},{"id":9,"href":"/repopres/en/docs/about/repopres/","title":"Repopres","section":"About","content":"repopres# Netizen\u0026rsquo;s Guide to Preserving Github Repositories\n"},{"id":10,"href":"/repopres/en/docs/contributions/contributions/","title":"Contributions","section":"Contributions","content":"Contributions# Interviewer# Jonathan M Farbowitz Emma Dickson Mark Hellar redactor# Ven Koel Haoran "}]