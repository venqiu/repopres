[{"id":0,"href":"/repopres/en/zh/docs/","title":"GitHub 仓库保存网民指南","section":"Zhs","content":"GitHub 仓库保存网民指南# 欢迎使用本指南，请通过左侧目录浏览内容。\n"},{"id":1,"href":"/repopres/en/en/docs/posts/introduction/","title":"Introduction","section":"Posts","content":"Introduction:\nThis is a decision guide for preserving a github repository. There are many approaches to doing this, with varying degrees of effort, difficulty, longevity, and dependability. The following guide outlines three main methods for preserving source code found on github.com.\nWhy is it important to preserve source code?\nSoftware has become an integral part of modern society, embodying significant portions of our cultural knowledge. However, as Di Cosmo and Zacchiroli eloquently state, unlike other forms of digital preservation, source code has not yet achieved the status of “first class citizen in the digital archive landscape.”\nWhy software is at risk:\nInherent obsolescence - Software depends on specific execution environments, languages, and dependencies that keep evolving and there is no unifying data model for version control systems.\nProject abandonment - Without active maintenance, the knowledge of specific softwares can be lost permanently.\nCensorship - Despite software frequently migrating between platforms, there is always a chance that code hosting platforms would remove content due to policy violations and political pressure.\nPlatform dependence - Most code hosting platforms do not offer any long term preservation guarantees. The 2015-16 shutdown of Gitorious and Google Code demonstrated this as over 1.5 millions projects had to relocate in a short timeframe.\nCurrent state of software preservation\nTwo major initiatives currently represent different approaches to software preservation. GitHub’s Arctic Code Vault takes a focused approach to creating a long-term physical backup. The initiative stores snapshots of public repositories in a decommissioned coal mine in the Svalbard archipelago, a location chosen for its geological stability. However, the Vault primarily focuses on creating snapshots rather than capturing complete development histories with all their evolution, functioning essentially more as a disaster recovery backup than an active archive.\nSoftware Heritage takes a fundamentally different approach to focus on broad accessibility and long-term viability. Rather than relying on a single backup location, Software Heritage maintains a geographic network of “mirrors” and operates on a principle of no a priori selection to archive comprehensively. As of June 2022, Software Heritage has archived over 180 million software origins with more than 12 billion unique source code files, making it the largest corpus of source code available on the planet.\nComponents of GitHub Repository\nUnderstanding what comprises a complete GItHub repository reveals the challenges in considering which elements are essential versus secondary.\nCore technical artifacts:\nSource code: The primary artifact Commit history: Record of changes that affect the file Branch: Separate workspace for new changes without affecting the main branch Tag: Marker referencing a specific commit within project history README: Overview documentation of the project License: Legal declaration governing use and distribution Recording these elements provides what might be called a comprehensive snapshot of the repository at a given point in time. This represents the minimum viable preservation effort as it captures the project with sufficient detail that future users could understand and potentially build upon the work. For software that never had significant community engagement, this level of preservation may be adequate.\nHowever, contemporary software development is an increasingly collaborative process. Preserving these secondary content provides a richer understanding of the repository as a community artifact, such as revealing the decision-making processes through which communities debate technical approaches, though the dynamic nature of these elements presents challenges for preservation.\nIssue and pull request: Bug reports and proposed code changes Wiki page: Extended, long-form information Project: Tool for planning and tracking work on GitHub Release: Software iteration for distribution including notes Actions: Platform allowing automated processes for continuous integration / continuous delivery Discussions: Collaborative communication forum The question of metadata and related materials\n[Added by ven] The question of metadata and related materials is a key one in archiving and software preservation. Different approaches to keeping and labeling the ancillary materials related to a piece of source code greatly shape the differences between preservation approaches.\nWhy software is at risk: inherent obsolescence, project abandonment, DMCA/copyright, censorship\nWhy is it hard to archive source code? What is the current state of software preservation The most extra: Github’s Arctic Vault The most open and encompassing: Software Heritage Components of Github Repository (easier said than done, conflicting information) Main content (recording this would just be a snapshot): source code, commit history, branches, tags, read.me, license Secondary content (recording this would be more like preserving a github repository): issues and pull requests, wiki pages, project boards, releases (?? isn’t this important), actions workflows, discussions "},{"id":2,"href":"/repopres/en/zh/docs/posts/%E4%BB%8B%E7%BB%8D/","title":"Introduction","section":"Posts","content":"介绍：\n本指南是一个用于保存 GitHub 仓库的决策向导，重点关注如何评估、准备并保存托管在 github.com 上的源代码。\n为什么要保存源代码？\n软件已经成为现代社会基础设施的一部分，它不仅是工具，也承载着文化、科学研究和社会实践等丰富信息。 如果今天的源代码无法被保存下来，未来的研究者将很难理解我们这一代的技术与社会运作方式。 因此，越来越多的档案机构开始把软件视为数字档案体系中的 “first-class citizen（第一等公民）”。\n软件为什么处在风险之中\n内在的易失性 软件依赖特定的执行环境，例如操作系统版本、依赖库、硬件架构和编译器。一旦这些环境不再被支持，软件就难以运行或重现。不同的版本控制系统（Git、Subversion 等）也各有自己的数据模型，目前并没有统一的长期保存格式。 项目被放弃 很多 GitHub 仓库是个人或小团队维护的，一旦维护者离开、兴趣转移或组织解散，代码就可能无人管理，随时面临被删除或 “消失” 的风险。 DMCA 与版权 GitHub 会根据 DMCA 通知下架仓库；版权纠纷或授权不清，也可能导致代码被迫移除。 审查与下架 在某些情况下，出于政策、公司策略或法律原因，仓库可能被平台隐藏或彻底删除。 一个 GitHub 仓库都包含什么\n一个仓库并不仅仅是源代码，它由多种组件构成：\n主要内容——“快照”部分 Source code（源代码） Commit history（提交历史） Branches（分支） Tags（标签） README 文件 License（许可证） 次要/周边内容——更接近“情境化保存” Issues：问题跟踪和讨论 Pull requests：合并请求和代码审查记录 Releases：正式发布版本及其附带文件 Actions workflows：GitHub Actions 自动化工作流 Projects / Wiki 等项目文档 Discussions：社区讨论区，用于更开放的协作交流 这些组成部分中，有些更适合被完整采集（例如源代码与提交历史），有些则只能以截图、导出或说明性文档的方式被“间接”保存。\n元数据与相关资料的问题\n元数据和相关资料（文档、截图、研究论文、用户手册等）对软件保存非常关键。 它们不仅帮助理解这份代码“做什么”，还说明了它在什么情境下被使用、谁参与了开发、有哪些依赖关系。这些差异会显著影响你选择哪一种保存路径与工具。\n总结：软件为什么难以归档？我们现在处在什么状态？\n软件面临的风险：内在易失性、项目被放弃、DMCA/版权、审查 关键问题包括： 为什么归档源代码这么困难？ 当前的软件保存生态是什么状况？ “最夸张”的例子：GitHub Arctic Code Vault（北极冷库） “最开放、覆盖面最广”的例子：Software Heritage 一个 GitHub 仓库的哪些组成部分值得保存？ 主要内容：源代码、提交历史、分支、标签、README、许可证等 次要内容：issue、pull request、release、actions workflow、discussions 等 "},{"id":3,"href":"/repopres/en/en/docs/","title":"Netizen's Guide to Preserving Github Repositories","section":"Ens","content":"Netizen\u0026rsquo;s Guide to Preserving Github Repositories# Welcome! Use the navigation on the left to browse the guide.\n"},{"id":4,"href":"/repopres/en/en/docs/posts/first-step/","title":"First steps: Evaluating","section":"Posts","content":"First steps: Evaluating\nBefore beginning the archival process, ask yourself fundamental questions about your goals and the repository’s significance.\nWhy Are You Archiving This Repository?\nUnderstanding your motivation helps determine the appropriate preservation approach:\nSoftware history preservation: Contributing to the history of software development\nPersonal backup: Ensuring your own work is safely stored\nCommunity preservation: Protecting software important to a specific community\nEmergency rescue: Saving at-risk code before it disappears\nResearch purposes: Preserving software for academic story or reproducibility\nAsk yourself, why are you archiving a github repository?\nHow to evaluate if a repository is worth preserving It’s significant in software history, technological development, or a specific community that you’re a part of It’s in danger of being removed, outlawed, or otherwise made inaccessible Software history or personal backup? Is it preserved already?\nCheck: Software Heritage Github Repository Evaluation Checklist\nHow complete and usable is the software? Are there fundamental issues that still have yet to be solved? Are there other dependencies that would not get covered by the source code? (idk) identify the code hosting places, from well known development platforms to niche archives try to accommodate specifics of source code’s hosting environment crawl development histories as captured by wide variety of version control systems (Git, Mercurial, Subversion, Darcs, Bazaar, CVS, \u0026amp; more) version_history.csv contains: director name, author name, author email, date original, curator name, curator email, release tag, commit message Tasks could involve: transcribing hand-written code, finding code from different hardware, interviews "},{"id":5,"href":"/repopres/en/zh/docs/posts/%E7%AC%AC%E4%B8%80%E6%AD%A5%E8%AF%84%E4%BC%B0/","title":"First steps: Evaluating","section":"Posts","content":"第一步：评估\n在真正开始归档之前，先问自己几个根本性的问题： 你为什么要保存这个仓库？它对谁重要？它在更大的软件生态里处于什么位置？\n你为什么要归档这个仓库？\n弄清动机有助于选择合适的保存策略：\n软件史保存： 为软件发展史贡献一份证据。 个人备份： 确保自己的作品安全、有地方可以找回。 社群保存： 为某个特定社区保存重要的软件资源。 在评估时，你可以考虑：\n你的目标更偏向哪一种？ 是软件历史？ 还是个人备份？ 这个软件是不是已经被保存到其他地方？ 可以先去查一查：Software Heritage 是否已经有这份代码。 GitHub Repository Evaluation Checklist（GitHub 仓库评估清单）： 软件是否相对完整、可用？ 是否还存在尚未解决的重大问题？ 是否依赖其他外部组件（例如外部服务、专有库）——这些东西只靠源代码无法覆盖？ 代码目前托管在哪些平台？ 从常见的开发平台到小众档案库，都要尽量列出。 归档时，能否尽量贴合原本的托管环境？ 例如镜像原始目录结构、保留原始仓库 URL 等。 能否抓取到版本控制系统中完整的开发历史？ 包括各种 VCS：Git、Mercurial、Subversion、Darcs、Bazaar、CVS 等。 对于一些更系统化的软件保存实践，你还可能会遇到专门的元数据表，例如一个 version_history.csv 可能包含：\ndirector name（项目负责人姓名） author name / email（作者姓名与邮箱） date original（最初发布日期） curator name / email（整理者姓名与邮箱） release tag（版本标签） commit message（提交说明） 可能涉及的任务包括：\n誊写手写的旧代码； 从不同硬件上找回散落的代码副本； 访谈开发者、维护者或使用者，补充背景信息。 这些步骤可以帮助你判断： 这个仓库值得投入多少保存工作，以及最适合把它送往哪一种保存路径。\n"},{"id":6,"href":"/repopres/en/en/docs/posts/decision-guide/","title":"Decision Guide","section":"Posts","content":"Decision Guide: Preservation Resources and Destinations:\nDepending on who you are and the skills you have, you may decide to preserve source code locally, through an organization like Software Heritage, or through your institution’s digital preservation system. There are pros and cons to each of these options:\nLocal route\nPros: You only need to rely on yourself You can make your own preservation decisions decide your own best practices (e.g. the types of metadata, ancillary materials, and other information to provide about each repo) Privacy: you have full control over the access of this software Cons: You are not bound to terms and services of any organization, or online platform, or copyright law You have to pay for your own storage space Software Heritage\nPros: Institutionally backed, sustained project with funding Rigorous archiving, centralized Contextualized with other softwares (good for software history) Cons: Subject to European copyright law Cannot change the metadata fields All decisions are subject to approval Institutional Route\nPros: Institutional resources and stability Digital preservationists and colleagues Cons: Need to work with the DAMS used by your institution already, which may not be suitable for archiving software "},{"id":7,"href":"/repopres/en/zh/docs/posts/%E5%86%B3%E7%AD%96%E6%8C%87%E5%8D%97%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E4%B8%8E%E7%9B%AE%E7%9A%84%E5%9C%B0/","title":"Decision Guide","section":"Posts","content":"决策指南：保存资源与目的地\n根据你的身份、可用资源和技术能力，你可以选择不同的路径来保存软件仓库：\n完全由自己在本地保存； 把源代码交给像 Software Heritage 这样的公共软件档案库； 或者与某个机构的数字保存系统合作。 每一种方案都有优点与局限，你可以根据下面的特点作出选择。\n本地保存路线# Pros 优点：\n只需要依赖你自己，不需要等待外部机构审批。 你可以自己制定保存策略： 例如文件夹结构、想要保存哪些相关材料（文档、截图、论文等）、需要记录哪些说明信息。 隐私控制完全在你手里： 你可以决定谁能访问这些软件、副本存放在哪里。 Cons 缺点：\n…（此处原文用省略号表示，具体劣势可根据你的实际情况补充） Software Heritage Route（Software Heritage 路线）# Pros 优点：\n有机构背书的长期项目，并且有稳定的资金与持续运营。 归档流程严谨、集中管理，适合长期保存。 你的软件会与其他项目放在一起，被放入更大的历史语境中——这对软件史研究非常有价值。 Cons 缺点：\n受欧洲版权法（European copyright law）约束。 元数据字段由 Software Heritage 定义，用户无法随意更改。 归档决策需要经过审核，某些请求可能不会被接受。 Institutional Route（机构路线）# Pros 优点：\n机构层面的资源与稳定性（经费、硬件、长期规划等）。 可以与数字保存人员（digital preservationists）及其他同事合作，为软件提供更完整的文献与上下文。 Cons 缺点：\n需要使用你所在机构已经部署的 DAMS（Digital Asset Management System）， 而这些系统未必是专门为软件归档设计的，有时会不太适配源代码和版本控制的特性。 "},{"id":8,"href":"/repopres/en/en/docs/posts/local-solution/","title":"Local Solution","section":"Posts","content":"Local Solution:\nLink to that MackinationsAI or make our own that has powershell commands and bash commands NDSA Standards (link to NDSA levels of digital preservation table) Tasks for Level 1 Tasks for Level 2 Tasks for Level 3 Tasks for Level 4 "},{"id":9,"href":"/repopres/en/zh/docs/posts/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%A1%88/","title":"Local Solution","section":"Posts","content":"本地方案：\n可以链接到现有的工具（例如 MackinationsAI），或自己制作一个脚本工具， 其中包含 PowerShell / Bash 等命令，帮助你半自动地完成备份与整理。 参考 NDSA Standards（NDSA《数字保存等级》（Levels of Digital Preservation））： （链接：NDSA levels of digital preservation） Tasks for Level 1（一级任务） Tasks for Level 2（二级任务） Tasks for Level 3（三级任务） Tasks for Level 4（四级任务） 通过这些等级，你可以把本地方案分解成一个个可执行的小步骤，从“可恢复的备份”逐步提升到“真正面向长期保存的多副本体系”。\n"},{"id":10,"href":"/repopres/en/en/docs/posts/software-heritage/","title":"Software Heritage","section":"Posts","content":"Software Heritage:\nAbout Software Heritage\nSoftware Heritage was founded in 2016, launched by Inria in partnership with UNESCO. Their mission is to “collect, preserve, and make readily accessible all the software source code ever written” (Source).Check if your repository is already by visiting their online archive at https://archive.softwareheritage.org/. If not, then issue an origin save request here.\nThe Software Heritage Acquisition Process\nIn their 2021 research paper, they outlined what they call the “Software Heritage Acquisition Process” (SWHAP). This process was developed to preserve source code from various sources, including but not limited to software development platforms like Github and Gitlab, legacy platforms like Google Code and Gitorious, package manager repositories like CPAn and npm, and FOSS (free and open source software) distributions such as Fedora and FreeBSD. The following contains a general overview of SWHAP so you can evaluate if Software Heritage is the right place for the code you’d like to preserve. You can find more information from their published research articles\nPhases\nCollect: Find the source code and related materials (e.g. research articles, pictures, drawings, user manuals) and gather it ‘as is’ Curate: Analyze and clean up the structure of raw materials (source code). This includes clarifying the production dates, contributors, and general history and evolution of the software. This information is logged as metadata, using vocabulary from CodeMet (e.g. software runtime platform, programming languages, authors, license) Archive: Upload or contribute the each category of materials to the appropriate infrastructures: Software Heritage for source code, Wikimedia for images and videos, open access repositories for research articles, Wikidata for software descriptions and properties, and so on Present: Create presentations, exhibitions, events, or websites from the results Software artifacts: How SWHAP divides their components\nThe following categories are how Software Heritage distinguishes the different components that make up the “raw materials” of software:\nfile contents (AKA ‘blobs’): the raw content of the source code in the form of bytes directories: a list of named directories, each pointing to other artifacts revisions (AKA ‘commits’): each recorded copy of the root directory is known as a revision releases (AKA tags): milestone revisions origins (software provenance): fine grained references to where source code artifacts have been retrieved from. projects: abstract entities that relate together several development resources, including websites, issue trackers, mailing lists, as well as software origins snapshots: records all entry points found there and where they pointed to. This would include branches for VCS, and suites for package distributions visits: link together software origins with snapshots. This is essentially a time stamp of when Software Heritage recorded a snapshot Metadata: version_history.csv ** **For each piece of software, the SWHAP recommends that preservationists collect relevant metadata file for each version of the software, in the form of a spreadsheet titled version_history.csv. Here is an example of one. These typically contain:\ndirector name: name of directory containing the source code of this version author name: name of the main author date original: original date when this version was made curator name: name of the curator person or team curator email: reference email of the acquisition process release tag: tag name if the directory contains a release, empty otherwise commit message: text containing a brief note from the curator team It is worth noting that modern VCS allow two sets of metadata: one for the author and one for the committer. This allows for the distinguishing between the original author of a software, and the person archiving it.\nExplain Merkle Direct Acyclic Graph (DAG) as their way of preventing unnecessary redundancies\nSoftware Heritages’ collection is in essence a big Merkle Direct Acyclic Graph (DAG), a multi-node structure in which each of the aforementioned software artifacts (file contents, directories, revisions) constitute one node. With each node having its own intrinsic cryptographic hash, Software Heritage is able to to avoid unnecessary duplication of code, contextualize source with the entire development of all source code in the collection, and establish provenance and code reuse.\nHow often Software Heritage scans for new code\nSoftware Heritage uses an adaptive scheduling discipline, specifically an “exponential backoff strategy.” This means that they run periodic checks of the source code they collect to scan for changes and edits. If the scan shows changes for any given software origin, they increase the frequency that that site is visited in the future. If the check does not show changes for the software, they decrease the scanning frequency.\nWhere they keep their data\n[discuss mirrors etc)\n"},{"id":11,"href":"/repopres/en/zh/docs/posts/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E9%81%97%E4%BA%A7/","title":"Software Heritage","section":"Posts","content":"关于软件遗产# Software Heritage 成立于 2016 年，由 Inria 发起，并与 UNESCO 合作。 它的使命是：“收集、保存，并让所有曾经写过的软件源代码可以被方便访问”。 他们主要从各种平台收集源代码，其中最重要的来源之一就是 GitHub。\n你可以先访问他们的在线档案： https://archive.softwareheritage.org/ 如果你的仓库还不在其中，可以通过保存请求页面发起 “origin save request”： https://archive.softwareheritage.org/save/\nSoftware Heritage 采集流程# 在 2021 年的研究论文中，Software Heritage 提出了 Software Heritage Acquisition Process（SWHAP） 的概念，用来描述他们如何系统性地收集和整理软件源代码。这套流程的目标是：\n覆盖尽可能多的软件托管平台； 保存完整的开发历史，而不仅仅是一份最新快照； 记录清楚来源、作者和后期整理者等“谱系信息”。 Phases（阶段）# （原文此处使用省略号，详细阶段可根据 SWHAP 论文补充）\n在具体的工作流程中，元数据表里通常会记录：\ndirector name（项目负责人） author name / email（作者姓名与邮箱） date original（最初发布日期） curator name / email（整理者姓名与邮箱） release tag（版本标签） commit message（整理团队写下的简短说明） 值得注意的是，现代版本控制系统（VCS）往往有两套不同的元数据：\n一套来自原始作者与开发团队（谁写了代码、何时提交）； 另一套来自后期的整理者或机构（谁抓取、谁审核、谁导入到档案系统）。 这种区分可以帮助研究者理解： 哪些信息来自原始开发活动，哪些则是归档过程本身留下的“第二层历史”。\nExplain Merkle Directed Acyclic Graph (DAG)（Merkle 有向无环图）# Software Heritage 的整个数据集合本质上是一个巨大的 Merkle DAG。 在这套结构中：\n每一个对象（文件、目录、提交）都通过散列值（hash）唯一标识； 对象之间的关系（例如一个目录包含哪些文件、一次提交指向哪些父提交）构成一个 有向无环图（Directed Acyclic Graph）； 这样的结构可以： 避免重复存储相同内容（去重）； 追踪版本之间的演化关系和重用关系； 为每个节点建立清晰的 provenance（来源）链条。 How often Software Heritage scans for new code（Software Heritage 多久抓取一次新代码）# Software Heritage 使用一种 adaptive scheduling discipline（自适应调度策略） 来决定何时重新抓取某个代码托管点：\n对更新频繁、活动活跃的仓库，会更频繁地扫描； 随时间观察到变化越来越少时，会逐步降低扫描频率； 这样既能保证新版本被及时收集，又不会浪费过多抓取和存储资源。 Where they keep their data（他们的数据存放在哪里）# （原文提示 “discuss mirrors etc”，即需要根据 Software Heritage 的镜像与备份策略进行补充说明。） 总体来说，Software Heritage 通过多个镜像站点和合作机构分布式保存数据，以降低单点故障和地域性风险。\n"},{"id":12,"href":"/repopres/en/en/docs/posts/institution/","title":"Institution","section":"Posts","content":"Institution\nSummarize Jonathan’s strategies, and other interviewees "},{"id":13,"href":"/repopres/en/zh/docs/posts/%E6%9C%BA%E6%9E%84/","title":"Institution","section":"Posts","content":"机构\nSummarize Jonathan’s strategies, and other interviewees （此处原文是写作提示：需要综合 Jonathan 以及其他受访者在与机构 / DAMS 合作时的策略。 在中文版本中，你可以根据访谈内容补充具体做法、技巧和经验。） "},{"id":14,"href":"/repopres/en/en/docs/posts/p2p-software-sharing-communities/","title":"P2P Software-Sharing Communities","section":"Posts","content":"P2P Software-Sharing Communities\nIf you believe the software you are attempting to preserve may not be welcome in on SWH, and you hope for more distribution and shared responsibility for preserving it beyond your own hard drive(s), then seeding it in P2P file-sharing communities may be the answer This is out of scope for this toolkit but if you are interested in joining then keep your eyes peeled on the subreddits and discords of communities such as [this] or [that] for opportunities to be invited into the community "},{"id":15,"href":"/repopres/en/zh/docs/posts/p2p%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB%E7%A4%BE%E7%BE%A4/","title":"P2P Software-Sharing Communities","section":"Posts","content":"P2P软件分享社群\n如果你认为自己要保存的软件不太适合放进像 Software Heritage 这样的公共档案库， 或者希望在自己的硬盘之外，有更多人一起分担保存责任，那么把它种子化， 分发到 P2P 文件分享社群 可能是一条出路。 本工具包并不打算详细介绍这些社群的运作方式，这是本项目的“超出范围”部分。 如果你对此感兴趣，可以长期关注相关社区的 subreddit、Discord 等渠道， 等待加入邀请或公开征集信息（例如 “[this]” 或 “[that]” 这样具体的社群链接）。 "},{"id":16,"href":"/repopres/en/en/docs/posts/how-to-get-more-involved/","title":"How to get more involved","section":"Posts","content":"How to get more involved?\nCiting SWH article: In the software preservation "},{"id":17,"href":"/repopres/en/zh/docs/posts/%E5%A6%82%E4%BD%95%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%8F%82%E4%B8%8E/","title":"How to get more involved","section":"Posts","content":"如何进一步参与？\nCiting SWH article: In the software preservation … （原文在此只留下了提示：可以引用 Software Heritage 的文章， 讨论在软件保存领域如何持续参与、做出贡献。 你可以在中文版本中补充：例如参与开源项目、向 Software Heritage 提交 save 请求、 在机构内推动软件保存政策等。） "},{"id":18,"href":"/repopres/en/en/docs/about/repopres/","title":"Repopres","section":"About","content":"repopres# Netizen\u0026rsquo;s Guide to Preserving Github Repositories\n"},{"id":19,"href":"/repopres/en/en/docs/contributions/contributions/","title":"Contributions","section":"Contributions","content":"Contributions# Interviewer# Jonathan M Farbowitz Emma Dickson Mark Hellar redactor# Ven Koel Haoran "},{"id":20,"href":"/repopres/en/zh/docs/about/repopres/","title":"Repopres","section":"About","content":"repopres# Netizen\u0026rsquo;s Guide to Preserving Github Repositories\n（《GitHub 仓库保存网民指南》）\n"},{"id":21,"href":"/repopres/en/zh/docs/contributions/%E8%B4%A1%E7%8C%AE%E8%80%85/","title":"贡献者","section":"Contributions 贡献","content":"Contributions 贡献# Interviewer 采访者# Jonathan M Farbowitz Emma Dickson Mark Hellar Redactor 编辑与撰写# Ven Koel Haoran "}]